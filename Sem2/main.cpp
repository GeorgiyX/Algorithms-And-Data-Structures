#include <iostream>


struct Point {
    int x;
    int y;
};

template<class T>
class IsLessBy3rdPoint {
public:
    IsLessBy3rdPoint(const Point _pt) {}

    // Оператор скобки называется "функтор", мы вообще всю эту тему с классов-функтором начали чтобы передвавать его
    // в нашу сортировку не меняя кода функции, а только аргумент (до этого там был 3й аргумент - указатель на функцию
    // сортировки с двумя аргументами. Вообще хорошая иллюстрация применения функтора.
    // Крч мы потом поменяли этот аргумент указатель на второй шаблонный тип и теперь наша функция работает и для
    // переменных-функторов и для указателей на функции сортировки, лишь бы bool возвращал и два арга принимал)
    bool operator()(const T &l, const T &r) {
        return true;
    }
};


std::ostream &operator<<(std::ostream &ostream, const Point &point) {
    ostream << "[" << point.x << ";" << point.y << "]";
}

bool operator<(const Point &l, const Point &r) {
    return l.x < r.x;
}

bool isLessByX(const Point &l, const Point &r) {
    return l.x < r.x;
}

//
//template<class T>
//void sort(T *arr, int l, int r) {
template<typename T>
void sort(T *arr, int l, int r, bool (*isLess)(const T &, const T &)) {
    for (int i = l; i < r; ++i) {
        for (int j = l; j < r; ++j) {
            if (isLess(arr[j + 1], arr[j])) {
                std::swap(arr[j], arr[j + 1]);
            }
        }

    }
}


int main() {
    int n = 0;
    std::cin >> n;
    auto arr = new Point[n];
    for (int i = 0; i < n; ++i) {
        std::cin >> arr[i].x >> arr[i].y;
    }
    sort(arr, 0, n, operator<);
    for (int j = 0; j < n; ++j) {
        std::cout << arr[j] << " ";

    }
    return 0;
}


// Задача 2: есть набор точек, нужно соединить их ломаной так чтобы она началась в одной точке и закончилась в другой,
// а ломаная не пересеклась. Для этого нужно осортировать точки по углу (12 часов) оносительно начальной точки
// (от нее пойдем соединять и походу она должна быть самой крайней..) и соединять в порядке возрастания угла.

// Как работает шаблоны: по переданному массиву он выводит тип Т и компилит с этим типым (еще нет), потом смотрит на
// второй шаблонный аргмуент - например указатель на функцию. Те вообще заметим что компилято запилит столько реализаций
// функций сколько есть вариантов шаблона (т.е. у нас фактический будет не одна функция как может показаться)

// Задача еще одна:
// Есть забор :), который красили в несколько слоев. Соответственно есть участки которые покрасили в два слоя, в три
// слоя или вообще не красили. Нужно определить напрмер во сколько слоев максимальнно покрашен забор или другое. Тут
// нужен метод сканирующей прямой, типо ведем рукой по забору и можем зафиксировать что на каком учаске забора +1 слой
// а на каком -1. Этим способом можно решать например задачу современнкими 5_2. Типо слой краски - это время когда чел
// современник (18-80 или возраст RIP), а забо это временнная прямая.

// Задача с показом рекламы: 