К №6.

Такое условие :`j > l || (pivot == arr[l] && j != i)`, обусловлено:
1. `j > l` - очевидный случай. После пивота идут меньшие элементы (`[4,1,3,2..]`), и итератор `j` выходит из своего `while` сразу на пивоте, делается финальный свап и это условие завершает работу партишина.
2. `j > l || (pivor == arr[l])` - следующая ступень эволюции. Если после пивота идет больший элемент (`[4,5,3,2..]`), то итератор останавливается на нем, делает обчный свап и соответственно становится равен нулю, но у нас еще небыло финального свапа - установки пивота на свое место. Это условие и помогает запуститься циклу еще раз.
3. `j > l || (pivot == arr[l] && j != i)` - окончательное условие. Если у нас массив состоит из одинаковых элементов или больших пивота (`[5,5,5,5..]`), то и условие `pivot == arr[i]` будет верно всегда, т.к. `i` будет двигаться одновременно с `j` (делая swap(x, x)) и они вместе дойдут до пивота и будут бесконечно свапать его самого на себя.. Потому ограничение `j != i` поможет устранить эту фишку.

Тут же можно отметить когда алгоритм поиска k-ой статистички работает за n*n: 
Например, когда у нас массив состоит из n одинаковых элементов, и мы ищем k = n - 1. Т.е. партишн будет выдвать нам всегда самый крайный элемент и так пока мы не доберемся до последнего элемента. Т.е. ему придется k=n раз просмотреть массив в которм в среднем n/2 элементов, n\*n\*0.5 => n\*n.